import React, { useState, useEffect, useMemo } from 'react';
import InputForm from './components/InputForm';
import StoryDisplay from './components/StoryDisplay';
import ImageDisplay from './components/ImageDisplay';
import LearningPath from './components/LearningPath';
import PlanReview from './components/PlanReview';
import QuizMode from './components/QuizMode';
import AuthModal from './components/AuthModal';
import { generateFullMnemonic, generateMnemonicImage, analyzeImageForBoundingBoxes, generateQuiz } from './services/geminiService';
import { isDue } from './services/srsService';
import { auth, stories as storyApi } from './services/api';
import { AppState, MnemonicResponse, SavedStory, Language, DailyReviewItem, SRSMetadata, User } from './types';

// Using small SVG data URLs as high-quality placeholders for demo images
const DEMO_ACS_IMAGE = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MDAiIGhlaWdodD0iMzAwIiB2aWV3Qm94PSIwIDAgNDAwIDMwMCI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2ZlZTJlMiIvPjx0ZXh0IHg9IjUwJSIgeT0iNDUlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIyOCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiNiOTFjMWMiPkFDUyBTY2VuZTwvdGV4dD48dGV4dCB4PSI1MCUiIHk9IjYwJSIgZG9taW5hbnQtYmFzZWxpbmU9Im1pZGRsZSIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTYiIGZpbGw9IiM3ZjFkMWQiIklsbHVzdHJhdGlvbiBQcmV2aWV3PC90ZXh0Pjwvc3ZnPg==";
const DEMO_RA_IMAGE = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0MDAiIGhlaWdodD0iMzAwIiB2aWV3Qm94PSIwIDAgNDAwIDMwMCI+PHJlY3Qgd2lkdGg9IjEwMCUiIGhlaWdodD0iMTAwJSIgZmlsbD0iI2UwZjJmZSIvPjx0ZXh0IHg9IjUwJSIgeT0iNDUlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIyOCIgZm9udC13ZWlnaHQ9ImJvbGQiIGZpbGw9IiMwMzY5YTEiPlJBIFNjZW5lPC90ZXh0Pjx0ZXh0IHg9IjUwJSIgeT0iNjAlIiBkb21pbmFudC1iYXNlbGluZT0ibWlkZGxlIiB0ZXh0LWFuY2hvcj0ibWlkZGxlIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNiIgZmlsbD0iIzA3NThhYSI+SWxsdXN0cmF0aW9uIFByZXZpZXc8L3RleHQ+PC9zdmc+";

const translations = {
  en: {
    appTitle: "MediMnemonic",
    myLearningPath: "My Learning Path",
    turnFactsIntoStories: "Turn Medical Facts into",
    unforgettableStories: "Unforgettable Stories",
    inputSubtitle: "Upload your lecture notes or paste a description. We extract high-yield facts and generate memorable mnemonics and visuals.",
    developingPlan: "Developing Mnemonic Plan...",
    generatingQuiz: "Generating Quiz...",
    paintingMemory: "Painting Your Memory Palace...",
    analyzingInput: "Analyzing your input and drafting a high-yield mnemonic story.",
    creatingQuestions: "Creating challenging questions based on your material.",
    generatingIllustration: "Generating a custom illustration based on your approved plan.",
    newConcept: "New Concept",
    detectingLocation: "Detecting location...",
    detectingAll: "Detecting all...",
    autoDetectAll: "Auto-Detect All",
    takeQuiz: "Take Quiz",
    save: "Save",
    verifyDisclaimer: "Information generated by AI may contain inaccuracies. Verify with medical textbooks.",
    storageFull: "Storage full! Could not save story with image. Try deleting old stories.",
    storySaved: "Story saved to Learning Path!",
    failedToGenerate: "Failed to generate mnemonic plan. Please try again with different input.",
    failedQuiz: "Failed to generate quiz. Please try again.",
    couldNotGenerateImage: "Could not generate visual mnemonic, but here is your story.",
    couldNotDetect: "Could not detect object location automatically.",
    textDescription: "Text Description",
    uploadPdf: "Upload PDF",
    pasteNotes: "Paste your medical notes or topic here",
    pastePlaceholder: "e.g. Describe the symptoms and treatment of Kawasaki Disease...",
    selectPdf: "Select a PDF file",
    processing: "Processing...",
    generateMnemonic: "Generate Mnemonic",
    reviewPlan: "Review & Edit Plan",
    step1: "Step 1 of 2",
    keyFacts: "Key Facts",
    factsToMemorize: "Facts to Memorize",
    theStory: "The Story",
    regenerateFacts: "Regenerate from Facts",
    memoryAnchors: "Memory Anchors",
    character: "Character",
    term: "Term",
    meaning: "Meaning",
    addAnchor: "+ Add Anchor",
    aiImageInstruction: "AI Image Instruction",
    updateStory: "Update based on Story",
    discard: "Discard & Start Over",
    generateVisual: "Generate Visual Mnemonic",
    topic: "Topic",
    addFact: "+ Add Fact",
    quizMode: "Quiz Mode",
    score: "Score",
    question: "Question",
    identifyConcept: "Identify the concept",
    lookHighlighted: "Look at the highlighted area in the image",
    correct: "Correct!",
    incorrect: "Incorrect",
    nextQuestion: "Next Question",
    finishQuiz: "Finish Quiz",
    quizComplete: "Quiz Complete!",
    youScored: "You scored",
    backToStudy: "Back to Study",
    retryQuiz: "Retry Quiz",
    noValidQuestions: "No valid quiz questions available for this topic.",
    extractedInfo: "Extracted High-Yield Info",
    mnemonicStory: "The Mnemonic Story",
    interactiveAnchors: "Interactive Memory Anchors",
    represents: "represents",
    locationNotSet: "Location not set (Drag or use Detect on image)",
    visualMnemonic: "Visual Mnemonic",
    controls: "Controls",
    resetBox: "Reset Box",
    addBox: "Add Box",
    detect: "Detect",
    remove: "Remove",
    downloadImage: "Download Image",
    noSavedStories: "No saved stories yet",
    createFirst: "Create your first mnemonic story to start building your library.",
    createMnemonic: "Create Mnemonic",
    delete: "Delete",
    viewStory: "View Story",
    narrator: "Narrator",
    dailyReview: "Daily Review",
    dueToday: "Due Today",
    startReview: "Start Daily Review",
    interleavedSession: "Interleaved Session",
    easy: "Easy",
    good: "Good",
    hard: "Hard",
    forgot: "Forgot",
    relearning: "Re-learning Loop",
    sessionSummary: "Session Summary",
    regenerateImage: "Regenerate Image"
  },
  es: {
    appTitle: "MediMnemotecnia",
    myLearningPath: "Mi Ruta de Aprendizaje",
    turnFactsIntoStories: "Convierte Datos MÃ©dicos en",
    unforgettableStories: "Historias Inolvidables",
    inputSubtitle: "Sube tus notas o pega una descripciÃ³n. Extraemos datos clave y generamos mnemotecnias y visuales memorables.",
    developingPlan: "Desarrollando Plan MnemotÃ©cnico...",
    generatingQuiz: "Generando Cuestionario...",
    paintingMemory: "Pintando tu Palacio de la Memoria...",
    analyzingInput: "Analizando tu entrada y redactando una historia mnemotÃ©cnica de alto rendimiento.",
    creatingQuestions: "Creando preguntas desafiantes basadas en tu material.",
    generatingIllustration: "Generando una ilustraciÃ³n personalizada basada en tu plan aprobado.",
    newConcept: "Nuevo Concepto",
    detectingLocation: "Detectando ubicaciÃ³n...",
    detectingAll: "Detectando todo...",
    autoDetectAll: "Auto-Detectar Todo",
    takeQuiz: "Tomar Quiz",
    save: "Guardar",
    verifyDisclaimer: "La informaciÃ³n generada por IA puede contener imprecisiones. Verifica con libros de texto mÃ©dicos.",
    storageFull: "Â¡Almacenamiento lleno! No se pudo guardar la historia. Intenta borrar historias antiguas.",
    storySaved: "Â¡Historia guardada en la Ruta de Aprendizaje!",
    failedToGenerate: "Error al generar el plan mnemotÃ©cnico. Intenta de nuevo con otra entrada.",
    failedQuiz: "Error al generar el cuestionario. Intenta de nuevo.",
    couldNotGenerateImage: "No se pudo generar la mnemotecnia visual, pero aquÃ­ estÃ¡ tu historia.",
    couldNotDetect: "No se pudo detectar la ubicaciÃ³n del objeto automÃ¡ticamente.",
    textDescription: "DescripciÃ³n de Texto",
    uploadPdf: "Subir PDF",
    pasteNotes: "Pega tus notas mÃ©dicas o tema aquÃ­",
    pastePlaceholder: "ej. Describe los sÃ­ntomas y tratamiento de la Enfermedad de Kawasaki...",
    selectPdf: "Selecciona un archivo PDF",
    processing: "Procesando...",
    generateMnemonic: "Generar Mnemotecnia",
    reviewPlan: "Review & Edit Plan",
    step1: "Paso 1 de 2",
    keyFacts: "Datos Clave",
    factsToMemorize: "Datos para Memorizar",
    theStory: "La Historia",
    regenerateFacts: "Regenerar desde Datos",
    memoryAnchors: "Anclas de Memoria",
    character: "Personaje",
    term: "TÃ©rmino",
    meaning: "Significado",
    addAnchor: "+ Agregar Ancla",
    aiImageInstruction: "InstrucciÃ³n de Imagen IA",
    updateStory: "Actualizar basado en Historia",
    discard: "Descartar y Empezar de Nuevo",
    generateVisual: "Generar Mnemotecnia Visual",
    topic: "Tema",
    addFact: "+ Agregar Dato",
    quizMode: "Modo Cuestionario",
    score: "Puntaje",
    question: "Pregunta",
    identifyConcept: "Identifica el concepto",
    lookHighlighted: "Mira el Ã¡rea resaltada en la imagen",
    correct: "Â¡Correcto!",
    incorrect: "Incorrecto",
    nextQuestion: "Siguiente Pregunta",
    finishQuiz: "Finalizar Quiz",
    quizComplete: "Â¡Quiz Completado!",
    youScored: "Obtuviste",
    backToStudy: "Volver a Estudiar",
    retryQuiz: "Reintentar Quiz",
    noValidQuestions: "No hay preguntas vÃ¡lidas disponibles para este tema.",
    extractedInfo: "InformaciÃ³n Clave ExtraÃ­da",
    mnemonicStory: "La Historia MnemotÃ©cnica",
    interactiveAnchors: "Anclas de Memoria Interactivas",
    represents: "representa",
    locationNotSet: "UbicaciÃ³n no definida (Arrastra o usa Detectar)",
    visualMnemonic: "Mnemotecnia Visual",
    controls: "Controles",
    resetBox: "Reiniciar Caja",
    addBox: "Agregar Caja",
    detect: "Detectar",
    remove: "Eliminar",
    downloadImage: "Descargar Imagen",
    noSavedStories: "AÃºn no hay historias guardadas",
    createFirst: "Crea tu primera historia mnemotÃ©cnica para empezar tu biblioteca.",
    createMnemonic: "Crear Mnemotecnia",
    delete: "Eliminar",
    viewStory: "Ver Historia",
    narrator: "Narrador",
    dailyReview: "Repaso Diario",
    dueToday: "Pendientes hoy",
    startReview: "Comenzar Repaso Diario",
    interleavedSession: "SesiÃ³n Intercalada",
    easy: "FÃ¡cil",
    good: "Bien",
    hard: "DifÃ­cil",
    forgot: "Olvidado",
    relearning: "Bucle de Re-aprendizaje",
    sessionSummary: "Resumen de la SesiÃ³n",
    regenerateImage: "Regenerar Imagen"
  }
};

const App: React.FC = () => {
  const [state, setState] = useState<AppState>({
    isLoading: false,
    step: 'input',
    error: null,
    factsData: null,
    data: null,
    imageData: null,
    highlightedIndex: null,
    savedStories: [],
    quizData: null,
    language: 'en',
    reviewQueue: [],
    user: null,
    showAuthModal: false
  });

  const [activeReviewItem, setActiveReviewItem] = useState<DailyReviewItem | null>(null);
  const [detectingIndex, setDetectingIndex] = useState<number | null>(null);
  const [detectingAll, setDetectingAll] = useState(false);

  const t = (key: keyof typeof translations['en']) => translations[state.language][key];

  // Auth & Initial Data Load
  useEffect(() => {
    const init = async () => {
      try {
        const user = await auth.me();
        setState(prev => ({ ...prev, user, showAuthModal: false }));
        // Load stories
        const stories = await storyApi.list();
        setState(prev => ({ ...prev, savedStories: stories }));
      } catch (e) {
        // Not authenticated
        setState(prev => ({ ...prev, showAuthModal: true }));
      }
    };
    init();
  }, []);

  const handleUpdateSRS = async (storyId: string, associationIndex: number, quality: number) => {
    try {
      const updatedStory = await storyApi.review(storyId, associationIndex, quality);
      setState(prev => ({
        ...prev,
        savedStories: prev.savedStories.map(s => s.id === storyId ? updatedStory : s)
      }));
    } catch (e) {
      console.error("SRS Update failed", e);
    }
  };

  const handleUpdateAssociation = async (index: number, box: [number, number, number, number] | undefined, shape: 'rect' | 'ellipse') => {
    if (!state.data) return;
    const newAssocs = [...state.data.associations];
    newAssocs[index] = { ...newAssocs[index], boundingBox: box, shape };
    const updatedData = { ...state.data, associations: newAssocs };
    setState(prev => ({ ...prev, data: updatedData }));

    // Auto-save if it's an existing story
    if ('id' in state.data) {
      try {
        const story = state.data as SavedStory;
        const updatedStory = await storyApi.update(story.id, { ...story, associations: newAssocs });
        setState(prev => ({
          ...prev,
          savedStories: prev.savedStories.map(s => s.id === story.id ? updatedStory : s)
        }));
      } catch (e) {
        console.error("Failed to update story", e);
      }
    }
  };

  const handleDetect = async (index: number) => {
    if (!state.imageData || !state.data) return;
    setDetectingIndex(index);
    try {
      const singleAssoc = [state.data.associations[index]];
      const result = await analyzeImageForBoundingBoxes(state.imageData, singleAssoc);
      const updatedBox = result[0].boundingBox;
      if (updatedBox) {
        handleUpdateAssociation(index, updatedBox, 'rect');
      } else {
        alert(t('couldNotDetect'));
      }
    } catch (e) {
      console.error(e);
    } finally {
      setDetectingIndex(null);
    }
  };

  const handleDetectAll = async () => {
    if (!state.imageData || !state.data) return;
    setDetectingAll(true);
    try {
      const results = await analyzeImageForBoundingBoxes(state.imageData, state.data.associations);
      const updatedAssocs = state.data.associations.map((assoc, idx) => {
        const match = results.find(r => r.medicalTerm === assoc.medicalTerm);
        return match ? { ...assoc, boundingBox: match.boundingBox } : assoc;
      });
      const updatedData = { ...state.data, associations: updatedAssocs };
      setState(prev => ({ ...prev, data: updatedData }));

      if ('id' in state.data) {
        try {
          const story = state.data as SavedStory;
          const updatedStory = await storyApi.update(story.id, { ...story, associations: updatedAssocs });
          setState(prev => ({
            ...prev,
            savedStories: prev.savedStories.map(s => s.id === story.id ? updatedStory : s)
          }));
        } catch (e) {
          console.error("Failed to update story", e);
        }
      }
    } catch (e) {
      console.error(e);
    } finally {
      setDetectingAll(false);
    }
  };

  const handleGenerateMnemonic = async (text: string, pdfBase64?: string) => {
    setState(prev => ({ ...prev, isLoading: true, step: 'generating_plan', error: null, highlightedIndex: null, factsData: null, data: null, quizData: null }));
    try {
      const fullResponse: MnemonicResponse = await generateFullMnemonic(text, pdfBase64, state.language);
      setState(prev => ({ ...prev, isLoading: false, data: fullResponse, factsData: { topic: fullResponse.topic, facts: fullResponse.facts }, step: 'review_plan' }));
    } catch (error: any) {
      console.error("Mnemonic generation process failed", error);
      setState(prev => ({ ...prev, isLoading: false, step: 'error', error: error.message || t('failedToGenerate') }));
    }
  };

  const handleApprovePlan = async (updatedData: MnemonicResponse) => {
    setState(prev => ({ ...prev, isLoading: true, data: updatedData, step: 'generating_image' }));
    try {
      const imageBase64 = await generateMnemonicImage(updatedData.visualPrompt);
      setState(prev => ({ ...prev, imageData: imageBase64, isLoading: false, step: 'complete' }));
    } catch (imgError) {
      console.error("Image generation failed", imgError);
      setState(prev => ({ ...prev, isLoading: false, step: 'complete', error: t('couldNotGenerateImage') }));
    }
  };

  const handleRegenerateImage = async () => {
    if (!state.data) return;
    setState(prev => ({ ...prev, isLoading: true }));
    try {
      const imageBase64 = await generateMnemonicImage(state.data.visualPrompt);
      setState(prev => {
        const newState = { ...prev, imageData: imageBase64, isLoading: false };
        // If story exists, update it
        if (prev.data && 'id' in prev.data) return newState;
        return newState;
      });

      if (state.data && 'id' in state.data) {
        // Update remote
        try {
          const story = state.data as SavedStory;
          const updatedStory = await storyApi.update(story.id, { ...story, imageData: imageBase64 });
          setState(prev => ({
            ...prev,
            savedStories: prev.savedStories.map(s => s.id === story.id ? updatedStory : s)
          }));
        } catch (e) { console.error(e); }
      }

    } catch (error) {
      console.error("Failed to regenerate image", error);
      alert(t('couldNotGenerateImage'));
      setState(prev => ({ ...prev, isLoading: false }));
    }
  };

  const handleStartDailyReview = async () => {
    setState(prev => ({ ...prev, isLoading: true, step: 'loading_quiz' }));
    try {
      const dueItems: DailyReviewItem[] = [];
      for (const story of state.savedStories) {
        const storyQuizzes = await generateQuiz(story, state.language);
        story.associations.forEach((assoc, idx) => {
          if (isDue(assoc.srs)) {
            const q = storyQuizzes.find(sq => sq.associationIndex === idx);
            if (q) {
              dueItems.push({
                storyId: story.id,
                topic: story.topic,
                imageData: story.imageData || null,
                association: assoc,
                question: q,
                relearnCount: 0
              });
            }
          }
        });
      }
      const shuffledQueue = dueItems.sort(() => Math.random() - 0.5);
      if (shuffledQueue.length > 0) {
        setState(prev => ({ ...prev, isLoading: false, step: 'daily_review', reviewQueue: shuffledQueue, error: null }));
        setActiveReviewItem(shuffledQueue[0]);
      } else {
        setState(prev => ({ ...prev, isLoading: false, step: 'library', error: "No due items today!" }));
      }
    } catch (e) {
      console.error("Failed to prepare daily review", e);
      setState(prev => ({ ...prev, isLoading: false, step: 'library', error: t('failedQuiz') }));
    }
  };

  const handleStartQuiz = async () => {
    if (!state.data) return;
    setState(prev => ({ ...prev, step: 'loading_quiz' }));
    try {
      const quiz = await generateQuiz(state.data, state.language);
      setState(prev => ({ ...prev, step: 'quiz', quizData: quiz, highlightedIndex: null }));
    } catch (e) {
      console.error("Quiz generation failed", e);
      alert(t('failedQuiz'));
      setState(prev => ({ ...prev, step: 'complete' }));
    }
  };

  const handleStartOver = () => {
    setState(prev => ({ ...prev, isLoading: false, step: 'input', error: null, factsData: null, data: null, imageData: null, highlightedIndex: null, quizData: null, reviewQueue: [] }));
    setActiveReviewItem(null);
  };

  if (state.showAuthModal) {
    return (
      <AuthModal
        onSuccess={async (user) => {
          const stories = await storyApi.list();
          setState(prev => ({ ...prev, user, showAuthModal: false, savedStories: stories }));
        }}
        onClose={() => { }}
      />
    );
  }

  if (state.step === 'library') {
    return (
      <LearningPath
        savedStories={state.savedStories}
        onSelectStory={(s) => setState(prev => ({ ...prev, step: 'complete', data: s, imageData: s.imageData || null }))}
        onBack={handleStartOver}
        onDelete={async (id) => {
          try {
            await storyApi.delete(id);
            setState(prev => ({ ...prev, savedStories: prev.savedStories.filter(s => s.id !== id) }));
          } catch (e) {
            alert("Failed to delete story.");
          }
        }}
        onStartReview={handleStartDailyReview}
        t={t}
      />
    );
  }

  return (
    <div className="min-h-screen bg-stone-50 text-slate-800 font-sans">
      <header className="bg-white shadow-sm border-b border-stone-200 sticky top-0 z-50">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-16 flex items-center justify-between">
          <div className="flex items-center gap-3 cursor-pointer" onClick={handleStartOver}>
            <div className="bg-teal-700 p-2 rounded-lg shadow-sm">
              <svg className="w-5 h-5 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19.428 15.428a2 2 0 00-1.022-.547l-2.384-.477a6 6 0 00-3.86.517l-.318.158a6 6 0 01-3.86.517L6.05 15.21a2 2 0 00-1.806.547M8 4h8l-1 v5.172a2 2 0 00.586 1.414l5 5c1.26 1.26.367 3.414-1.415 3.414H4.828c-1.782 0-2.674-2.154-1.414-3.414l5-5A2 2 0 009 10.172V5L8 4z" />
              </svg>
            </div>
            <h1 className="text-xl font-bold text-slate-800 tracking-tight">
              {state.language === 'en' ? 'Medi' : 'Medi'}<span className="text-teal-700">{state.language === 'en' ? 'Mnemonic' : 'Mnemotecnia'}</span>
            </h1>
          </div>
          <div className="flex items-center gap-4">
            {state.user && <span className="text-sm text-slate-500 font-medium">Hello, {state.user.username}</span>}
            <button onClick={() => setState(prev => ({ ...prev, language: prev.language === 'en' ? 'es' : 'en' }))} className="text-sm font-bold text-teal-700 border border-teal-200 rounded-md px-3 py-1 hover:bg-teal-50 transition-colors">
              {state.language === 'en' ? 'ğŸ‡ªğŸ‡¸ ES' : 'ğŸ‡ºğŸ‡¸ EN'}
            </button>
            <button onClick={() => setState(prev => ({ ...prev, step: 'library' }))} className="text-sm font-semibold text-slate-500 hover:text-teal-700 transition-colors">
              {t('myLearningPath')}
            </button>
          </div>
        </div>
      </header>

      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        {state.error && (
          <div className="mb-6 bg-red-50 border-l-4 border-red-500 p-4 rounded-r-lg shadow-sm">
            <p className="text-sm text-red-700">{state.error}</p>
          </div>
        )}

        {state.step === 'input' && (
          <div className="flex flex-col items-center justify-center min-h-[60vh]">
            <div className="text-center mb-10 max-w-2xl">
              <h2 className="text-4xl font-extrabold text-slate-900 mb-4 tracking-tight leading-tight">
                {t('turnFactsIntoStories')} <br /> <span className="text-teal-700">{t('unforgettableStories')}</span>
              </h2>
              <p className="text-lg text-slate-600">{t('inputSubtitle')}</p>
            </div>
            <InputForm onSubmit={handleGenerateMnemonic} isLoading={state.isLoading} t={t} />
          </div>
        )}

        {state.step === 'review_plan' && state.data && (
          <PlanReview data={state.data} onApprove={handleApprovePlan} onCancel={handleStartOver} t={t} language={state.language} />
        )}

        {(state.step === 'generating_plan' || (state.step === 'generating_image' && !state.imageData) || state.step === 'loading_quiz') && (
          <div className="flex flex-col items-center justify-center min-h-[50vh] animate-fade-in">
            <div className="w-24 h-24 mb-6 relative">
              <div className="absolute inset-0 border-4 border-stone-200 rounded-full"></div>
              <div className="absolute inset-0 border-4 border-teal-600 rounded-full border-t-transparent animate-spin"></div>
              <div className="absolute inset-0 flex items-center justify-center text-3xl">
                {state.step === 'loading_quiz' ? 'ğŸ“' : 'ğŸ§ '}
              </div>
            </div>
            <h3 className="text-2xl font-bold text-slate-800 mb-2">
              {state.step === 'generating_plan' ? t('developingPlan') : state.step === 'loading_quiz' ? t('generatingQuiz') : t('paintingMemory')}
            </h3>
          </div>
        )}

        {state.step === 'daily_review' && (
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <QuizMode
              isInterleaved
              reviewQueue={state.reviewQueue}
              t={t}
              onExit={() => setState(prev => ({ ...prev, step: 'library' }))}
              onUpdateSRS={handleUpdateSRS}
              setHighlightIndex={(idx) => setState(prev => ({ ...prev, highlightedIndex: idx }))}
              onCurrentItemChange={setActiveReviewItem}
            />
            <ImageDisplay
              imageData={activeReviewItem?.imageData || null}
              isLoading={false}
              topic={activeReviewItem?.topic}
              associations={activeReviewItem ? [activeReviewItem.association] : []}
              highlightedIndex={0}
              t={t}
            />
          </div>
        )}

        {state.data && (state.step === 'complete' || state.step === 'quiz') && (
          <div className="animate-fade-in-up space-y-8">
            <div className="flex justify-between items-center bg-white p-3 rounded-xl border border-stone-200 shadow-sm">
              <button onClick={handleStartOver} className="text-sm font-semibold text-slate-500 hover:text-teal-700 flex items-center px-2">
                <svg className="w-4 h-4 mr-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" /></svg>
                {t('newConcept')}
              </button>
              <div className="flex items-center gap-4">
                {state.step === 'complete' && (
                  <button onClick={handleStartQuiz} className="inline-flex items-center px-4 py-2 border border-stone-200 text-sm font-semibold rounded-lg text-slate-700 bg-white hover:bg-stone-50 transition-all shadow-sm">
                    <svg className="w-4 h-4 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" /></svg>
                    {t('takeQuiz')}
                  </button>
                )}
                <button onClick={async () => {
                  const newStory: SavedStory = { ...state.data!, id: Date.now().toString(), createdAt: Date.now(), imageData: state.imageData || undefined };
                  // Backend Create
                  try {
                    const created = await storyApi.create(newStory);
                    setState(prev => ({
                      ...prev,
                      savedStories: [created, ...prev.savedStories]
                    }));
                    alert(t('storySaved'));
                  } catch (e) {
                    console.error(e);
                    alert("Failed to save story");
                  }
                }} className="inline-flex items-center px-5 py-2 border border-transparent text-sm font-bold rounded-lg shadow-sm text-white bg-teal-700 hover:bg-teal-800 transition-all">
                  {t('save')}
                </button>
              </div>
            </div>
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
              {state.step === 'quiz' ? (
                <QuizMode
                  quizData={state.quizData!}
                  t={t}
                  onExit={() => setState(prev => ({ ...prev, step: 'complete' }))}
                  onUpdateSRS={handleUpdateSRS} // SRS Update from Quiz now uses handleUpdateSRS which calls API
                  setHighlightIndex={(idx) => setState(prev => ({ ...prev, highlightedIndex: idx }))}
                />
              ) : (
                <StoryDisplay data={state.data} highlightedIndex={state.highlightedIndex} onHighlight={(i) => setState(prev => ({ ...prev, highlightedIndex: i }))} t={t} language={state.language} />
              )}
              <ImageDisplay
                imageData={state.imageData}
                isLoading={state.isLoading}
                topic={state.data.topic}
                associations={state.data.associations}
                highlightedIndex={state.highlightedIndex}
                onUpdateAssociation={handleUpdateAssociation}
                onDetect={handleDetect}
                onDetectAll={handleDetectAll}
                isDetecting={detectingIndex !== null}
                isDetectingAll={detectingAll}
                t={t}
                onRegenerateImage={handleRegenerateImage}
              />
            </div>
          </div>
        )}
      </main>
      <footer className="bg-white border-t border-stone-200 py-6 mt-12">
        <div className="max-w-7xl mx-auto px-4 text-center text-slate-400 text-sm">
          &copy; {new Date().getFullYear()} MediMnemonic. {t('verifyDisclaimer')}
        </div>
      </footer>
    </div>
  );
};

export default App;
